<?xml version='1.0' encoding='UTF-8'?>

<bag xmlns:float="http://www.w3.org/2001/XMLSchema#float" xmlns:int="http://www.w3.org/2001/XMLSchema#int" xmlns:unsignedInt="http://www.w3.org/2001/XMLSchema#unsignedInt" xmlns:unsignedLong="http://www.w3.org/2001/XMLSchema#unsignedLong" int:version="4">
 <issues>
  <issue>
   <unsignedInt:flags>69</unsignedInt:flags>
   <id>issue_inefficient_map</id>
   <int:severity>3</int:severity>
   <text>There is a high of percentage memory instructions with irregular (variable or random) stride accesses. Improve performance by investigating and handling accordingly. </text>
   <title>Inefficient memory access patterns present </title>
   <attributes>
    <float:severity>3</float:severity>
   </attributes>
   <parameters/>
   <recommendations>
    <recommendation>
     <int:confidence>3</int:confidence>
     <unsignedInt:flags>8</unsignedInt:flags>
     <id>rec_inefficient_map_sdlt_c</id>
     <text>The cost of rewriting code to organize data using SoA instead of AoS may outweigh the benefit. To fix: Use Intel SIMD Data Layout Templates (Intel SDLT), introduced in version 16.1 of the Intel compiler, to mitigate the cost. Intel SDLT is a C++11 template library that may reduce code rewrites to just a few lines. &lt;/br&gt;
&lt;b&gt;Read More:&lt;/b&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;C++/17/index.htm#GUID-F434587D-0F2D-4AC6-9D12-9988E2FDB751.htm&quot;&gt;Introduction to the Intel&amp;reg; SIMD Data Layout Templates (Intel&amp;reg; SDLT)&lt;/a&gt; &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/vectorization-resources-advisor&quot;&gt;Vectorization Resources for Intel&amp;reg; Advisor Users&lt;/a&gt; &lt;/ul&gt; </text>
     <title>Use Intel SDLT </title>
     <attributes>
      <float:confidence>3</float:confidence>
     </attributes>
     <parameters/>
    </recommendation>
    <recommendation>
     <int:confidence>1</int:confidence>
     <unsignedInt:flags>8</unsignedInt:flags>
     <id>rec_inefficient_map_soa_c</id>
     <text>An array is the most common type of data structure containing a contiguous collection of data items that can be accessed by an ordinal index. You can organize this data as an array of structures (AoS) or as a structure of arrays (SoA). While AoS organization is excellent for encapsulation, it can hinder effective vector processing. To fix: Rewrite code to organize data using SoA instead of AoS. &lt;/br&gt; &lt;b&gt;Read More:&lt;/b&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;C++/17/index.htm#GUID-D284C1EE-BFA4-4EA3-BB67-4A3E5D50199F.htm&quot;&gt;Programming Guidelines for Vectorization&lt;/a&gt; &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/a-case-study-comparing-aos-arrays-of-structures-and-soa-structures-of-arrays-data-layouts&quot;&gt;Case study: Comparing Arrays of Structures and Structures of Arrays Data Layouts for a Compute-Intensive Loop&lt;/a&gt; &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/vectorization-resources-advisor&quot;&gt;Vectorization Resources for Intel&amp;reg; Advisor Users&lt;/a&gt; &lt;/ul&gt; </text>
     <title>Use SoA instead of AoS </title>
     <attributes>
      <float:confidence>1</float:confidence>
     </attributes>
     <parameters/>
    </recommendation>
   </recommendations>
   <unsignedLong:rowKey>5</unsignedLong:rowKey>
  </issue>
  <issue>
   <unsignedInt:flags>66</unsignedInt:flags>
   <id>compiler_diag_issue_15542</id>
   <int:severity>1</int:severity>
   <text>&lt;b&gt;Cause:&lt;/b&gt; The inner loop in a nested loop is vectorized. &lt;br/&gt; &lt;b&gt;C++ Example:&lt;/b&gt;
&lt;div class=&quot;sample&quot;&gt;&lt;br/&gt;#define N 1000&lt;br/&gt;
float A[N][N];&lt;br/&gt;
void foo(int n){&lt;br/&gt;
&amp;nbsp;&amp;nbsp;int i,j;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (i=0; i &amp;lt; n; i++){&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (j=0; j &amp;lt; n; j++){&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;A[i][j]++;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
} &lt;/div&gt;  </text>
   <title>Inner loop was already vectorized </title>
   <attributes>
    <float:severity>1</float:severity>
   </attributes>
   <parameters/>
   <recommendations>
    <recommendation>
     <int:confidence>1</int:confidence>
     <unsignedInt:flags>8</unsignedInt:flags>
     <id>compiler_diag_rec_15542</id>
     <text>Force vectorization of the outer loop: &lt;ul&gt; &lt;li&gt;In some cases it is possible to collapse a nested loop structure into a single loop structure using a directive before the outer loop. The &lt;div class=&quot;inplace_sample&quot;&gt;n&lt;/div&gt; argument is an integer that specifies how many loops to collapse into one loop for vectorization: &lt;table&gt; &lt;tr&gt; &lt;th&gt;Target &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICL/ICC/ICPC&lt;/a&gt; Directive &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;IFORT&lt;/a&gt; Directive &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Outer loop &lt;/td&gt; &lt;td&gt;#pragma omp simd collapse(n), #pragma omp simd, or #pragma simd&lt;/td&gt; &lt;td&gt;!$OMP SIMD COLLAPSE(n), !$OMP SIMD, or !DIR$ SIMD&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/li&gt; &lt;li&gt;If using the &lt;div class=&quot;inplace_sample&quot;&gt;O3&lt;/div&gt; compiler option, use a directive before the inner and outer loops to request vectorization of the outer loop: &lt;table&gt; &lt;tr&gt; &lt;th&gt;Target &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICL/ICC/ICPC&lt;/a&gt; Directive &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;IFORT&lt;/a&gt; Directive &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Inner loop &lt;/td&gt; &lt;td&gt;#pragma novector&lt;/td&gt; &lt;td&gt;!DIR$ NOVECTOR&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Outer loop&lt;/td&gt; &lt;td&gt;#pragma vector always&lt;/td&gt; &lt;td&gt;!DIR$ VECTOR ALWAYS&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/li&gt; &lt;/ul&gt; &lt;b&gt;Read More C++ Information:&lt;/b&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/cdiag15542&quot;&gt;https://software.intel.com/en-us/articles/cdiag15542&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;C++/17/index.htm#GUID-CFBEC461-748D-4162-A669-C4F42848267F.htm&quot;&gt;novector&lt;/a&gt;, &lt;a href=&quot;C++/17/index.htm#GUID-CDCCCACD-A61C-40C5-A342-E452C95E1608.htm&quot;&gt;O&lt;/a&gt;, &lt;a href=&quot;C++/17/index.htm#GUID-4D8CDB9C-8A96-4CB2-B5E5-3D81003FE4FF.htm&quot;&gt;omp simd&lt;/a&gt;, &lt;a href=&quot;C++/17/index.htm#GUID-1EA04294-988E-4152-B584-B028FD6FAC48.htm&quot;&gt;simd&lt;/a&gt;, &lt;a href=&quot;C++/17/index.htm#GUID-2B528C72-29B4-4DBC-8B91-EE4D1A03A850.htm&quot;&gt;vector&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/getting-started-with-intel-composer-xe-2013-compiler-pragmas-and-directives&quot;&gt;Getting Started with Intel Compiler Pragmas and Directives&lt;/a&gt; and &lt;a href=&quot;https://software.intel.com/en-us/vectorization-resources-advisor&quot;&gt;Vectorization Resources for Intel&amp;reg; Advisor XE Users&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;  </text>
     <title>Recommendations </title>
     <attributes>
      <float:confidence>1</float:confidence>
     </attributes>
     <parameters/>
    </recommendation>
   </recommendations>
   <unsignedLong:rowKey>8</unsignedLong:rowKey>
  </issue>
  <issue>
   <unsignedInt:flags>66</unsignedInt:flags>
   <id>compiler_diag_issue_15333</id>
   <int:severity>1</int:severity>
   <text>&lt;b&gt;Cause:&lt;/b&gt; The compiler automatically generates a try block for a program block (that is, code inside {}) when it allocates a large, local object or array on the heap (because the object is too big to allocate on the stack) and a function within the block could throw an exception. &lt;br/&gt; &lt;b&gt;C++ Example:&lt;/b&gt;&lt;/br&gt; &lt;div class=&quot;sample&quot;&gt;__attribute__((vector)) void f1(double);&lt;br/&gt;
int main() &lt;br/&gt;
{&lt;br/&gt;
  int n = 10000;&lt;br/&gt;
  double a[n];&lt;br/&gt;
  #pragma simd&lt;br/&gt;
  for(int i = 0 ; i &amp;lt; n ; i++)&lt;br/&gt;
    f1(a[i]);&lt;br/&gt;
}&lt;/div&gt;  </text>
   <title>Exception Handling For a Call Prevents Vectorization </title>
   <attributes>
    <float:severity>1</float:severity>
   </attributes>
   <parameters/>
   <recommendations>
    <recommendation>
     <int:confidence>1</int:confidence>
     <unsignedInt:flags>8</unsignedInt:flags>
     <id>compiler_diag_rec_15333</id>
     <text>Avoid exceptions within a vectorizable loop body by marking functions as &lt;div class=&quot;inplace_sample&quot;&gt;nothrow&lt;/div&gt;.
&lt;div class=&quot;sample&quot;&gt;__attribute__((vector, nothrow)) void f1(double);&lt;/div&gt; </text>
     <title>Recommendations </title>
     <attributes>
      <float:confidence>1</float:confidence>
     </attributes>
     <parameters/>
    </recommendation>
   </recommendations>
   <unsignedLong:rowKey>21</unsignedLong:rowKey>
  </issue>
  <issue>
   <unsignedInt:flags>98</unsignedInt:flags>
   <id>compiler_diag_issue_15335</id>
   <int:severity>1</int:severity>
   <text>&lt;b&gt;Cause:&lt;/b&gt; The compiler vectorizer determined the loop will not benefit from vectorization. Common reasons include: &lt;ul&gt; &lt;li&gt;Non-unit stride memory access&lt;/li&gt; &lt;li&gt;Indirect memory access&lt;/li&gt; &lt;li&gt;Low iteration count&lt;/li&gt; &lt;/ul&gt; &lt;b&gt;C++ Example:&lt;/b&gt; The compiler vectorizer determines the cost of creating a vector operand (non-unit stride access in the vector operand creation) is significant when compared to the number/type of computations in which those vector operands are used. &lt;div class=&quot;sample&quot;&gt;&lt;br/&gt;
#include &amp;lt;iostream&amp;gt; &lt;br/&gt;
#define N 100&lt;br/&gt;
struct s1 {&lt;br/&gt;
int a, b, c;&lt;br/&gt;
}&lt;br/&gt;
int main(){&lt;br/&gt;
s1 arr[N], sum;&lt;br/&gt;
&lt;b&gt;for(int i = 0; i &amp;lt; N; i++)&lt;/b&gt;&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;sum.a += arr[i].a;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;sum.b += arr[i].b;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;sum.c += arr[i].c;&lt;br/&gt;
}&lt;br/&gt;
std::cout &amp;lt;&amp;lt; sum.a &amp;lt;&amp;lt; &quot;t&quot; &amp;lt;&amp;lt; sum.b &amp;lt;&amp;lt; &quot;t&quot; &amp;lt;&amp;lt; sum.c &amp;lt;&amp;lt; &quot;n&quot;; &lt;br/&gt;
return 0;&lt;br/&gt;
}&lt;/div&gt; </text>
   <title>Loop vectorization possible but seems inefficient </title>
   <attributes>
    <float:severity>1</float:severity>
   </attributes>
   <parameters/>
   <recommendations>
    <recommendation>
     <int:confidence>1</int:confidence>
     <unsignedInt:flags>40</unsignedInt:flags>
     <id>compiler_diag_rec_15335</id>
     <text>&lt;ul&gt; &lt;li&gt;If you still believe vectorization might result in a speedup, override the compiler cost model using a directive before the loop &lt;table&gt; &lt;tr&gt; &lt;th&gt;Target &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICL/ICC/ICPC&lt;/a&gt; Directive &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;IFORT&lt;/a&gt; Directive &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Source loop&lt;/td&gt; &lt;td&gt;#pragma vector or #pragma vector always&lt;/td&gt; &lt;td&gt;!DIR$ VECTOR or !DIR$ VECTOR ALWAYS&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; Alternatively, use a compiler option to always vectorize loops. The compiler will still test for dependencies and will not vectorize the loop unless it is safe. &lt;table&gt; &lt;tr&gt; &lt;th&gt;Windows* OS - &lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICL&lt;/a&gt; and &lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;IFORT&lt;/a&gt; Option&lt;/th&gt; &lt;th&gt;Linux* OS - &lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICC/ICPC&lt;/a&gt; and &lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;IFORT&lt;/a&gt; Option&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;/Qvec-threshold0&lt;/td&gt; &lt;td&gt;-vec-threshold0&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/li&gt; &lt;li&gt;Require vectorization using a directive before the loop. The compiler will not perform a dependency analysis; it is your responsibility to ensure vectorization is safe: &lt;table&gt; &lt;tr&gt; &lt;th&gt;Target &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICL/ICC/ICPC&lt;/a&gt; Directive &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;IFORT&lt;/a&gt; Directive &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Source loop&lt;/td&gt; &lt;td&gt;#pragma simd or #pragma omp simd &lt;/td&gt; &lt;td&gt;!DIR$ SIMD or !$OMP SIMD &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/li&gt; &lt;li&gt;Rewrite the data structure/loop to have more regular memory accesses. &lt;/li&gt; &lt;/ul&gt; &lt;b&gt;Read More C++ Information:&lt;/b&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/cdiag15335&quot;&gt;https://software.intel.com/en-us/articles/cdiag15335&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;C++/17/index.htm#GUID-4D8CDB9C-8A96-4CB2-B5E5-3D81003FE4FF.htm&quot;&gt;omp simd&lt;/a&gt;, &lt;a href=&quot;C++/17/index.htm#GUID-1EA04294-988E-4152-B584-B028FD6FAC48.htm&quot;&gt;simd&lt;/a&gt;, &lt;a href=&quot;C++/17/index.htm#GUID-C7A523F1-B43D-4AF7-920A-5B155E0823EE.htm&quot;&gt;vec-threshold&lt;/a&gt;, &lt;a href=&quot;C++/17/index.htm#GUID-2B528C72-29B4-4DBC-8B91-EE4D1A03A850.htm&quot;&gt;vector&lt;/a&gt; &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/getting-started-with-intel-composer-xe-2013-compiler-pragmas-and-directives&quot;&gt;Getting Started with Intel Compiler Pragmas and Directives&lt;/a&gt; and &lt;a href=&quot;https://software.intel.com/en-us/vectorization-resources-advisor&quot;&gt;Vectorization Resources for Intel&amp;reg; Advisor XE Users&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;  </text>
     <title>Recommendations </title>
     <attributes>
      <float:confidence>1</float:confidence>
     </attributes>
     <parameters/>
    </recommendation>
   </recommendations>
   <unsignedLong:rowKey>32</unsignedLong:rowKey>
  </issue>
  <issue>
   <unsignedInt:flags>98</unsignedInt:flags>
   <id>compiler_diag_issue_15335</id>
   <int:severity>1</int:severity>
   <text>&lt;b&gt;Cause:&lt;/b&gt; The compiler vectorizer determined the loop will not benefit from vectorization. Common reasons include: &lt;ul&gt; &lt;li&gt;Non-unit stride memory access&lt;/li&gt; &lt;li&gt;Indirect memory access&lt;/li&gt; &lt;li&gt;Low iteration count&lt;/li&gt; &lt;/ul&gt; &lt;b&gt;C++ Example:&lt;/b&gt; The compiler vectorizer determines the cost of creating a vector operand (non-unit stride access in the vector operand creation) is significant when compared to the number/type of computations in which those vector operands are used. &lt;div class=&quot;sample&quot;&gt;&lt;br/&gt;
#include &amp;lt;iostream&amp;gt; &lt;br/&gt;
#define N 100&lt;br/&gt;
struct s1 {&lt;br/&gt;
int a, b, c;&lt;br/&gt;
}&lt;br/&gt;
int main(){&lt;br/&gt;
s1 arr[N], sum;&lt;br/&gt;
&lt;b&gt;for(int i = 0; i &amp;lt; N; i++)&lt;/b&gt;&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;sum.a += arr[i].a;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;sum.b += arr[i].b;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;sum.c += arr[i].c;&lt;br/&gt;
}&lt;br/&gt;
std::cout &amp;lt;&amp;lt; sum.a &amp;lt;&amp;lt; &quot;t&quot; &amp;lt;&amp;lt; sum.b &amp;lt;&amp;lt; &quot;t&quot; &amp;lt;&amp;lt; sum.c &amp;lt;&amp;lt; &quot;n&quot;; &lt;br/&gt;
return 0;&lt;br/&gt;
}&lt;/div&gt; </text>
   <title>Loop vectorization possible but seems inefficient </title>
   <attributes>
    <float:severity>1</float:severity>
   </attributes>
   <parameters/>
   <recommendations>
    <recommendation>
     <int:confidence>1</int:confidence>
     <unsignedInt:flags>40</unsignedInt:flags>
     <id>compiler_diag_rec_15335</id>
     <text>&lt;ul&gt; &lt;li&gt;If you still believe vectorization might result in a speedup, override the compiler cost model using a directive before the loop &lt;table&gt; &lt;tr&gt; &lt;th&gt;Target &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICL/ICC/ICPC&lt;/a&gt; Directive &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;IFORT&lt;/a&gt; Directive &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Source loop&lt;/td&gt; &lt;td&gt;#pragma vector or #pragma vector always&lt;/td&gt; &lt;td&gt;!DIR$ VECTOR or !DIR$ VECTOR ALWAYS&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; Alternatively, use a compiler option to always vectorize loops. The compiler will still test for dependencies and will not vectorize the loop unless it is safe. &lt;table&gt; &lt;tr&gt; &lt;th&gt;Windows* OS - &lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICL&lt;/a&gt; and &lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;IFORT&lt;/a&gt; Option&lt;/th&gt; &lt;th&gt;Linux* OS - &lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICC/ICPC&lt;/a&gt; and &lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;IFORT&lt;/a&gt; Option&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;/Qvec-threshold0&lt;/td&gt; &lt;td&gt;-vec-threshold0&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/li&gt; &lt;li&gt;Require vectorization using a directive before the loop. The compiler will not perform a dependency analysis; it is your responsibility to ensure vectorization is safe: &lt;table&gt; &lt;tr&gt; &lt;th&gt;Target &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICL/ICC/ICPC&lt;/a&gt; Directive &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;IFORT&lt;/a&gt; Directive &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Source loop&lt;/td&gt; &lt;td&gt;#pragma simd or #pragma omp simd &lt;/td&gt; &lt;td&gt;!DIR$ SIMD or !$OMP SIMD &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/li&gt; &lt;li&gt;Rewrite the data structure/loop to have more regular memory accesses. &lt;/li&gt; &lt;/ul&gt; &lt;b&gt;Read More C++ Information:&lt;/b&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/cdiag15335&quot;&gt;https://software.intel.com/en-us/articles/cdiag15335&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;C++/17/index.htm#GUID-4D8CDB9C-8A96-4CB2-B5E5-3D81003FE4FF.htm&quot;&gt;omp simd&lt;/a&gt;, &lt;a href=&quot;C++/17/index.htm#GUID-1EA04294-988E-4152-B584-B028FD6FAC48.htm&quot;&gt;simd&lt;/a&gt;, &lt;a href=&quot;C++/17/index.htm#GUID-C7A523F1-B43D-4AF7-920A-5B155E0823EE.htm&quot;&gt;vec-threshold&lt;/a&gt;, &lt;a href=&quot;C++/17/index.htm#GUID-2B528C72-29B4-4DBC-8B91-EE4D1A03A850.htm&quot;&gt;vector&lt;/a&gt; &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/getting-started-with-intel-composer-xe-2013-compiler-pragmas-and-directives&quot;&gt;Getting Started with Intel Compiler Pragmas and Directives&lt;/a&gt; and &lt;a href=&quot;https://software.intel.com/en-us/vectorization-resources-advisor&quot;&gt;Vectorization Resources for Intel&amp;reg; Advisor XE Users&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;  </text>
     <title>Recommendations </title>
     <attributes>
      <float:confidence>1</float:confidence>
     </attributes>
     <parameters/>
    </recommendation>
   </recommendations>
   <unsignedLong:rowKey>313</unsignedLong:rowKey>
  </issue>
  <issue>
   <unsignedInt:flags>66</unsignedInt:flags>
   <id>compiler_diag_issue_15542</id>
   <int:severity>1</int:severity>
   <text>&lt;b&gt;Cause:&lt;/b&gt; The inner loop in a nested loop is vectorized. &lt;br/&gt; &lt;b&gt;C++ Example:&lt;/b&gt;
&lt;div class=&quot;sample&quot;&gt;&lt;br/&gt;#define N 1000&lt;br/&gt;
float A[N][N];&lt;br/&gt;
void foo(int n){&lt;br/&gt;
&amp;nbsp;&amp;nbsp;int i,j;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (i=0; i &amp;lt; n; i++){&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (j=0; j &amp;lt; n; j++){&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;A[i][j]++;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
} &lt;/div&gt;  </text>
   <title>Inner loop was already vectorized </title>
   <attributes>
    <float:severity>1</float:severity>
   </attributes>
   <parameters/>
   <recommendations>
    <recommendation>
     <int:confidence>1</int:confidence>
     <unsignedInt:flags>8</unsignedInt:flags>
     <id>compiler_diag_rec_15542</id>
     <text>Force vectorization of the outer loop: &lt;ul&gt; &lt;li&gt;In some cases it is possible to collapse a nested loop structure into a single loop structure using a directive before the outer loop. The &lt;div class=&quot;inplace_sample&quot;&gt;n&lt;/div&gt; argument is an integer that specifies how many loops to collapse into one loop for vectorization: &lt;table&gt; &lt;tr&gt; &lt;th&gt;Target &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICL/ICC/ICPC&lt;/a&gt; Directive &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;IFORT&lt;/a&gt; Directive &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Outer loop &lt;/td&gt; &lt;td&gt;#pragma omp simd collapse(n), #pragma omp simd, or #pragma simd&lt;/td&gt; &lt;td&gt;!$OMP SIMD COLLAPSE(n), !$OMP SIMD, or !DIR$ SIMD&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/li&gt; &lt;li&gt;If using the &lt;div class=&quot;inplace_sample&quot;&gt;O3&lt;/div&gt; compiler option, use a directive before the inner and outer loops to request vectorization of the outer loop: &lt;table&gt; &lt;tr&gt; &lt;th&gt;Target &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICL/ICC/ICPC&lt;/a&gt; Directive &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;IFORT&lt;/a&gt; Directive &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Inner loop &lt;/td&gt; &lt;td&gt;#pragma novector&lt;/td&gt; &lt;td&gt;!DIR$ NOVECTOR&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Outer loop&lt;/td&gt; &lt;td&gt;#pragma vector always&lt;/td&gt; &lt;td&gt;!DIR$ VECTOR ALWAYS&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/li&gt; &lt;/ul&gt; &lt;b&gt;Read More C++ Information:&lt;/b&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/cdiag15542&quot;&gt;https://software.intel.com/en-us/articles/cdiag15542&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;C++/17/index.htm#GUID-CFBEC461-748D-4162-A669-C4F42848267F.htm&quot;&gt;novector&lt;/a&gt;, &lt;a href=&quot;C++/17/index.htm#GUID-CDCCCACD-A61C-40C5-A342-E452C95E1608.htm&quot;&gt;O&lt;/a&gt;, &lt;a href=&quot;C++/17/index.htm#GUID-4D8CDB9C-8A96-4CB2-B5E5-3D81003FE4FF.htm&quot;&gt;omp simd&lt;/a&gt;, &lt;a href=&quot;C++/17/index.htm#GUID-1EA04294-988E-4152-B584-B028FD6FAC48.htm&quot;&gt;simd&lt;/a&gt;, &lt;a href=&quot;C++/17/index.htm#GUID-2B528C72-29B4-4DBC-8B91-EE4D1A03A850.htm&quot;&gt;vector&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/getting-started-with-intel-composer-xe-2013-compiler-pragmas-and-directives&quot;&gt;Getting Started with Intel Compiler Pragmas and Directives&lt;/a&gt; and &lt;a href=&quot;https://software.intel.com/en-us/vectorization-resources-advisor&quot;&gt;Vectorization Resources for Intel&amp;reg; Advisor XE Users&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;  </text>
     <title>Recommendations </title>
     <attributes>
      <float:confidence>1</float:confidence>
     </attributes>
     <parameters/>
    </recommendation>
   </recommendations>
   <unsignedLong:rowKey>313</unsignedLong:rowKey>
  </issue>
  <issue>
   <unsignedInt:flags>69</unsignedInt:flags>
   <id>issue_inefficient_map</id>
   <int:severity>3</int:severity>
   <text>There is a high of percentage memory instructions with irregular (variable or random) stride accesses. Improve performance by investigating and handling accordingly. </text>
   <title>Inefficient memory access patterns present </title>
   <attributes>
    <float:severity>3</float:severity>
   </attributes>
   <parameters/>
   <recommendations>
    <recommendation>
     <int:confidence>3</int:confidence>
     <unsignedInt:flags>8</unsignedInt:flags>
     <id>rec_inefficient_map_sdlt_c</id>
     <text>The cost of rewriting code to organize data using SoA instead of AoS may outweigh the benefit. To fix: Use Intel SIMD Data Layout Templates (Intel SDLT), introduced in version 16.1 of the Intel compiler, to mitigate the cost. Intel SDLT is a C++11 template library that may reduce code rewrites to just a few lines. &lt;/br&gt;
&lt;b&gt;Read More:&lt;/b&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;C++/17/index.htm#GUID-F434587D-0F2D-4AC6-9D12-9988E2FDB751.htm&quot;&gt;Introduction to the Intel&amp;reg; SIMD Data Layout Templates (Intel&amp;reg; SDLT)&lt;/a&gt; &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/vectorization-resources-advisor&quot;&gt;Vectorization Resources for Intel&amp;reg; Advisor Users&lt;/a&gt; &lt;/ul&gt; </text>
     <title>Use Intel SDLT </title>
     <attributes>
      <float:confidence>3</float:confidence>
     </attributes>
     <parameters/>
    </recommendation>
    <recommendation>
     <int:confidence>1</int:confidence>
     <unsignedInt:flags>8</unsignedInt:flags>
     <id>rec_inefficient_map_soa_c</id>
     <text>An array is the most common type of data structure containing a contiguous collection of data items that can be accessed by an ordinal index. You can organize this data as an array of structures (AoS) or as a structure of arrays (SoA). While AoS organization is excellent for encapsulation, it can hinder effective vector processing. To fix: Rewrite code to organize data using SoA instead of AoS. &lt;/br&gt; &lt;b&gt;Read More:&lt;/b&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;C++/17/index.htm#GUID-D284C1EE-BFA4-4EA3-BB67-4A3E5D50199F.htm&quot;&gt;Programming Guidelines for Vectorization&lt;/a&gt; &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/a-case-study-comparing-aos-arrays-of-structures-and-soa-structures-of-arrays-data-layouts&quot;&gt;Case study: Comparing Arrays of Structures and Structures of Arrays Data Layouts for a Compute-Intensive Loop&lt;/a&gt; &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/vectorization-resources-advisor&quot;&gt;Vectorization Resources for Intel&amp;reg; Advisor Users&lt;/a&gt; &lt;/ul&gt; </text>
     <title>Use SoA instead of AoS </title>
     <attributes>
      <float:confidence>1</float:confidence>
     </attributes>
     <parameters/>
    </recommendation>
   </recommendations>
   <unsignedLong:rowKey>314</unsignedLong:rowKey>
  </issue>
  <issue>
   <unsignedInt:flags>65</unsignedInt:flags>
   <id>issue_peel_remainder</id>
   <int:severity>3</int:severity>
   <text>All or some &lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;source loop&lt;/a&gt; iterations are not executing in the &lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;loop body&lt;/a&gt;. Improve performance by moving source loop iterations from &lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;peeled&lt;/a&gt;/&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;remainder&lt;/a&gt; loops to the loop body. </text>
   <title>Ineffective peeled/remainder loop(s) present </title>
   <attributes>
    <float:severity>3</float:severity>
   </attributes>
   <parameters/>
   <recommendations>
    <recommendation>
     <int:confidence>3</int:confidence>
     <unsignedInt:flags>8</unsignedInt:flags>
     <id>rec_peel_remainder_unroll_prevents_c</id>
     <text>The &lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;trip count&lt;/a&gt; after loop unrolling is too small compared to the &lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;vector length&lt;/a&gt;. To fix: Prevent loop &lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;unrolling&lt;/a&gt; or decrease the unroll factor using a &lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;directive&lt;/a&gt;: &lt;div class=&quot;inplace_sample&quot;&gt;#pragma nounroll&lt;/div&gt; or &lt;div class=&quot;inplace_sample&quot;&gt;#pragma unroll(N)&lt;/div&gt;.&lt;/br&gt; &lt;b&gt;Read More:&lt;/b&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;C++/17/index.htm#GUID-30B36136-E399-4D7A-9BF8-06D96B8536E9.htm&quot;&gt;unroll/nounroll&lt;/a&gt; &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/getting-started-with-intel-composer-xe-2013-compiler-pragmas-and-directives&quot;&gt;Getting Started with Intel Compiler Pragmas and Directives&lt;/a&gt; and &lt;a href=&quot;https://software.intel.com/en-us/vectorization-resources-advisor&quot;&gt;Vectorization Resources for Intel&amp;reg; Advisor Users&lt;/a&gt; &lt;/ul&gt; </text>
     <title>Disable unrolling </title>
     <attributes>
      <float:confidence>3</float:confidence>
     </attributes>
     <parameters/>
    </recommendation>
    <recommendation>
     <int:confidence>1</int:confidence>
     <unsignedInt:flags>8</unsignedInt:flags>
     <id>rec_peel_remainder_loop_count_c</id>
     <text>The compiler cannot statically detect the &lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;trip count&lt;/a&gt;. To fix: Identify the expected number of iterations using a &lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;directive&lt;/a&gt;: &lt;div class=&quot;inplace_sample&quot;&gt;#pragma loop_count&lt;/div&gt;.&lt;/br&gt; &lt;b&gt;Example: &lt;/b&gt;Iterate through a loop a minimum of three, maximum of ten, and average of five times: &lt;div class=&quot;sample&quot;&gt; #include &amp;lt;stdio.h&amp;gt;&lt;br/&gt; int mysum(int start, int end, int a) {&lt;br/&gt; int iret=0; &lt;br/&gt; #pragma loop_count min(3), max(10), avg(5)&lt;br/&gt; for (int i=start;i&lt;=end;i++)&lt;br/&gt; iret += a;&lt;br/&gt; return iret; &lt;br/&gt; } &lt;br/&gt; &lt;br/&gt; int main() {&lt;br/&gt; int t;&lt;br/&gt; t = mysum(1, 10, 3);&lt;br/&gt; printf(&quot;t1=%d\r\n&quot;,t);&lt;br/&gt; t = mysum(2, 6, 2);&lt;br/&gt; printf(&quot;t2=%d\r\n&quot;,t);&lt;br/&gt; t = mysum(5, 12, 1);&lt;br/&gt; printf(&quot;t3=%d\r\n&quot;,t);&lt;br/&gt; } &lt;/div&gt; &lt;b&gt;Read More:&lt;/b&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;C++/17/index.htm#GUID-5C5112FB-898C-41E4-86EA-0CFC27591F39.htm&quot;&gt;loop_count&lt;/a&gt; &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/getting-started-with-intel-composer-xe-2013-compiler-pragmas-and-directives&quot;&gt;Getting Started with Intel Compiler Pragmas and Directives&lt;/a&gt; and &lt;a href=&quot;https://software.intel.com/en-us/vectorization-resources-advisor&quot;&gt;Vectorization Resources for Intel&amp;reg; Advisor Users&lt;/a&gt; &lt;/ul&gt; </text>
     <title>Specify the expected loop trip count </title>
     <attributes>
      <float:confidence>1</float:confidence>
     </attributes>
     <parameters/>
    </recommendation>
   </recommendations>
   <unsignedLong:rowKey>314</unsignedLong:rowKey>
  </issue>
 </issues>
</bag>
